generator client {

  provider = "prisma-client-js"

}

datasource db {

  provider = "postgresql"

  url      = env("DATABASE_URL")

}

model User {

  id        Int      @id @default(autoincrement())

  email     String   @unique

  firstName String?

  lastName  String?

  phone     String?

  address   String?

  password  String

  role      String   @default("user")

  tickets   Ticket[]

  createdAt DateTime @default(now())

  updatedAt DateTime @updatedAt

}

model Station {

  id        Int      @id @default(autoincrement())

  name      String   @unique

  city      String

  latitude  Float

  longitude Float

  createdAt DateTime @default(now())

  updatedAt DateTime @updatedAt

  // Relations for route stations
  previousStations RouteStation[] @relation("PreviousStation")
  currentStations  RouteStation[] @relation("CurrentStation")
  nextStations     RouteStation[] @relation("NextStation")

  startRoutes TrainRoute[] @relation("StartStation")

  endRoutes   TrainRoute[] @relation("EndStation")

  scheduleStations ScheduleStation[]

  fromTickets Ticket[] @relation("TicketFromStation")

  toTickets   Ticket[] @relation("TicketToStation")

}

model TrainRoute {

  id           Int           @id @default(autoincrement())

  name         String        @unique

  startStationId Int

  endStationId   Int

  startStation Station       @relation("StartStation", fields: [startStationId], references: [id])

  endStation   Station       @relation("EndStation", fields: [endStationId], references: [id])

  routeStations RouteStation[]

  trains       Train[]

  schedules    TrainSchedule[]

  createdAt    DateTime      @default(now())

  updatedAt    DateTime      @updatedAt

}

model RouteStation {

  id                Int        @id @default(autoincrement())

  trainRouteId      Int

  trainRoute        TrainRoute @relation(fields: [trainRouteId], references: [id], onDelete: Cascade)

  previousStationId Int?

  currentStationId  Int

  nextStationId     Int?

  distance          Float?     // Distance to next station

  distanceFromStart Float      // Distance from start of route

  previousStation   Station?   @relation("PreviousStation", fields: [previousStationId], references: [id])

  currentStation    Station    @relation("CurrentStation", fields: [currentStationId], references: [id])

  nextStation       Station?   @relation("NextStation", fields: [nextStationId], references: [id])

  createdAt         DateTime   @default(now())

  updatedAt         DateTime   @updatedAt

}

model Compartment {

  id        Int      @id @default(autoincrement())

  name      String

  class     String   // e.g., "First", "Second", "Third"

  type      String   // e.g., "AC", "Non-AC", "Sleeper"

  price     Float    // Price per kilometer

  totalSeats Int     // Total number of seats in this compartment type

  trainCompartments TrainCompartment[]

  createdAt DateTime @default(now())

  updatedAt DateTime @updatedAt

}

model Train {

  id           Int          @id @default(autoincrement())

  name         String       // Train name

  number       String       @unique // Train number

  trainRouteId Int

  trainRoute   TrainRoute   @relation(fields: [trainRouteId], references: [id])

  compartments TrainCompartment[]

  schedules    TrainSchedule[]

  createdAt    DateTime     @default(now())

  updatedAt    DateTime     @updatedAt

}

model TrainCompartment {

  id            Int         @id @default(autoincrement())

  trainId       Int

  compartmentId Int

  quantity      Int         // Number of this compartment type in the train

  train         Train       @relation(fields: [trainId], references: [id], onDelete: Cascade)

  compartment   Compartment @relation(fields: [compartmentId], references: [id])

  seats         Seat[]

  tickets       Ticket[]    // Tickets booked in this compartment

  compartmentBookings CompartmentBooking[]

  createdAt     DateTime    @default(now())

  updatedAt     DateTime    @updatedAt

}

model Seat {

  id                Int             @id @default(autoincrement())

  trainCompartmentId Int

  trainCompartment  TrainCompartment @relation(fields: [trainCompartmentId], references: [id], onDelete: Cascade)

  seatNumber        String          // e.g., "1A", "2B", "15C"

  isAvailable       Boolean         @default(true)

  ticket            Ticket?         // Nullable - seat can be unbooked

  createdAt         DateTime        @default(now())

  updatedAt         DateTime        @updatedAt

  @@unique([trainCompartmentId, seatNumber]) // Ensure unique seat numbers per compartment

}

model TrainSchedule {

  id            Int       @id @default(autoincrement())

  trainId       Int

  trainRouteId  Int

  train         Train     @relation(fields: [trainId], references: [id], onDelete: Cascade)

  trainRoute    TrainRoute @relation(fields: [trainRouteId], references: [id])

  date          DateTime  // Schedule date

  time          String    // Departure time (HH:MM format)

  stationTimes  ScheduleStation[]

  tickets       Ticket[]

  compartmentBookings CompartmentBooking[]

  createdAt     DateTime  @default(now())

  updatedAt     DateTime  @updatedAt

  @@unique([trainId, date]) // Prevent duplicate schedules for same train on same date

}

model ScheduleStation {

  id                Int           @id @default(autoincrement())

  trainScheduleId   Int

  trainSchedule     TrainSchedule @relation(fields: [trainScheduleId], references: [id], onDelete: Cascade)

  stationId         Int

  station           Station       @relation(fields: [stationId], references: [id])

  arrivalTime       String?       // Arrival time at this station (HH:MM format)

  departureTime     String?       // Departure time from this station (HH:MM format)

  sequence          Int           // Order of station in the schedule

  createdAt         DateTime      @default(now())

  updatedAt         DateTime      @updatedAt

}

model Ticket {

  id                Int           @id @default(autoincrement())

  ticketId          String        @unique // Human-readable ticket ID (e.g., "EXP123-20241205-001A")

  userId            Int

  user              User          @relation(fields: [userId], references: [id])

  trainScheduleId   Int

  trainSchedule     TrainSchedule @relation(fields: [trainScheduleId], references: [id])

  fromStationId     Int

  fromStation       Station       @relation("TicketFromStation", fields: [fromStationId], references: [id])

  toStationId       Int

  toStation         Station       @relation("TicketToStation", fields: [toStationId], references: [id])

  seatId            Int           @unique // Reference to specific seat - unique for one-to-one relation

  seat              Seat          @relation(fields: [seatId], references: [id])

  trainCompartmentId Int          // Store train compartment ID for better performance

  trainCompartment  TrainCompartment @relation(fields: [trainCompartmentId], references: [id])

  seatNumber        String        // Store seat number for easy access (e.g., "1A", "2B")

  passengerName     String

  passengerAge      Int

  passengerGender   String        // "Male", "Female", "Other"

  price             Float

  status            String        @default("pending") // "pending", "confirmed", "cancelled", "expired"
  paymentStatus     String        @default("pending") // "pending", "paid", "failed", "cancelled"
  expiresAt         DateTime? // Auto-calculated: createdAt + 10 minutes
  confirmedAt       DateTime?

  createdAt         DateTime      @default(now())

  updatedAt         DateTime      @updatedAt

  paymentTransactions PaymentTransaction[]

}

model PaymentTransaction {

  id                String   @id @default(cuid())

  ticketId          Int      @unique

  ticket            Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  

  // SSLCommerz transaction details

  transactionId     String   @unique // SSLCommerz transaction ID

  sessionKey        String?  // SSLCommerz session key

  amount            Float

  currency          String   @default("BDT")

  

  // Payment status

  status            String   // "pending", "completed", "failed", "cancelled", "refunded"

  paymentMethod     String?  // Card, Mobile, etc.

  bankTransactionId String?

  valId             String?  // SSLCommerz validation ID

  cardType          String?  // Card type (VISA, MASTER, etc.)

  completedAt       DateTime? // When payment was completed

  gatewayUrl        String?  // SSLCommerz gateway URL

  errorMessage      String?  // Error message if payment failed

  metadata          Json?    // Additional customer/payment metadata

  

  // SSLCommerz response data

  sslcommerzData    Json?    // Store full SSLCommerz response

  

  createdAt         DateTime @default(now())

  updatedAt         DateTime @updatedAt

}

model PaymentLog {

  id            String   @id @default(cuid())

  transactionId String

  action        String   // "INITIATED", "COMPLETED", "FAILED", "CANCELLED"

  details       Json     // Store webhook/callback data

  createdAt     DateTime @default(now())

}

model CompartmentBooking {

  id                Int             @id @default(autoincrement())

  trainScheduleId   Int

  trainSchedule     TrainSchedule   @relation(fields: [trainScheduleId], references: [id], onDelete: Cascade)

  trainCompartmentId Int

  trainCompartment  TrainCompartment @relation(fields: [trainCompartmentId], references: [id], onDelete: Cascade)

  bookedSeats       Int             @default(0) // Number of seats currently booked

  totalSeats        Int             // Total seats in this compartment type

  createdAt         DateTime        @default(now())

  updatedAt         DateTime        @updatedAt

  @@unique([trainScheduleId, trainCompartmentId]) // One record per compartment per schedule

}